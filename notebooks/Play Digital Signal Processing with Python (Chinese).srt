1
00:00:02.048 --> 00:00:02.816
大家好

2
00:00:03.840 --> 00:00:05.632
你喜歡聽音樂嗎?

3
00:00:05.888 --> 00:00:09.216
會不會希望自己的音響喇叭音色可以更好?

4
00:00:09.472 --> 00:00:12.032
或者是你想要買副更棒的耳機

5
00:00:12.544 --> 00:00:14.848
可是好的音響喇叭非常貴

6
00:00:15.104 --> 00:00:17.664
而市面上的耳機型號這麼多

7
00:00:17.920 --> 00:00:19.456
又該如何抉擇呢?

8
00:00:19.968 --> 00:00:21.504
就針對喇叭來說

9
00:00:21.760 --> 00:00:24.064
到底該如何評斷優劣呢?

10
00:00:25.344 --> 00:00:27.136
喇叭就好比是歌手

11
00:00:27.648 --> 00:00:31.232
我們可以透過喇叭播含有高、中、低音的音頻訊號

12
00:00:31.488 --> 00:00:33.792
就能知道這個喇叭的音色是如何

13
00:00:34.304 --> 00:00:36.864
但是這個音頻訊號是什麼內容

14
00:00:37.120 --> 00:00:40.448
透過喇叭所播放出來結果又該如何分析

15
00:00:40.704 --> 00:00:43.008
有辦法數據化、視覺化嗎?

16
00:00:43.264 --> 00:00:45.824
又有著什麼樣 判斷優劣的標準呢?

17
00:00:46.592 --> 00:00:48.128
究竟聲音是什麼?

18
00:00:48.640 --> 00:00:54.784
不論是你講話、唱歌、或者透過喇叭來播放音樂

19
00:00:55.040 --> 00:01:01.184
聲音都是由多個頻率所組成 我們可以藉由傅立葉轉換來分析各個

20
00:01:01.440 --> 00:01:04.000
頻率的分佈與強度

21
00:01:07.840 --> 00:01:13.984
我們可以透過一個麥克風來收音 然後做傅立葉轉換 就可以分析一段

22
00:01:14.240 --> 00:01:20.384
聲音的頻率組成 例如我們可以產生一個420加上1000 20的

23
00:01:20.640 --> 00:01:21.920
複合訊號

24
00:01:22.176 --> 00:01:28.320
就可以透過傅立葉轉換 清楚的在頻譜圖上看到

25
00:01:28.576 --> 00:01:29.600
這兩個頻率

26
00:01:30.112 --> 00:01:31.136
的強度大小

27
00:01:31.904 --> 00:01:34.464
我們也可以產生一個白噪音

28
00:01:37.024 --> 00:01:43.168
各位可以看到 這就是白噪音的頻率組成

29
00:01:44.960 --> 00:01:46.496
白噪音是什麼呢?

30
00:01:46.752 --> 00:01:49.312
依據頻率之間能量分佈不同

31
00:01:49.568 --> 00:01:50.592
噪音可以

32
00:01:50.848 --> 00:01:51.872
分為很多種

33
00:01:52.384 --> 00:01:55.712
白噪音的特徵是它含有所有的頻率

34
00:01:56.224 --> 00:01:58.784
而且每個頻率的能量強弱相同

35
00:01:59.296 --> 00:02:03.392
所以我們就可以用白噪音來探測一個喇叭的音色是否均衡

36
00:02:04.416 --> 00:02:07.232
像是這個喇叭的高低音都不足

37
00:02:07.488 --> 00:02:12.864
就可以藉由播放白噪音而從頻譜圖中很清楚地看出來

38
00:02:13.632 --> 00:02:16.704
這就是喇叭的頻率響應曲線

39
00:02:16.960 --> 00:02:20.288
我們就可以藉以判斷喇叭的音色特性

40
00:02:21.568 --> 00:02:27.712
一個好的喇叭就應該像是一面透明的玻璃 忠實地呈現原始音色

41
00:02:28.480 --> 00:02:30.528
所以播放白噪音的時候

42
00:02:30.784 --> 00:02:33.856
頻譜圖看起來應該是水平的一條線

43
00:02:34.880 --> 00:02:39.744
那麼我們有辦法把這個喇叭的頻率響應曲線拉平嗎?

44
00:02:40.512 --> 00:02:42.560
當然有! 我們可以用等化器

45
00:02:43.584 --> 00:02:45.120
等化器有很多種

46
00:02:45.376 --> 00:02:47.168
其中一種常用的是

47
00:02:47.424 --> 00:02:50.240
Parametric EQ，簡稱 PEQ

48
00:02:50.752 --> 00:02:51.776
他的參數有:

49
00:02:52.032 --> 00:02:52.800
中心頻率

50
00:02:53.056 --> 00:02:54.592
Q值 與 增益

51
00:02:56.128 --> 00:02:58.176
首先我們設定中心頻率

52
00:02:58.688 --> 00:03:01.248
決定要針對哪個頻率做處理

53
00:03:02.784 --> 00:03:03.552
其次

54
00:03:04.320 --> 00:03:05.344
設定增益

55
00:03:05.600 --> 00:03:06.368
來衰減

56
00:03:07.136 --> 00:03:08.160
或加強它

57
00:03:11.232 --> 00:03:14.304
Q值的大小會決定 影響的頻率範圍

58
00:03:19.936 --> 00:03:24.032
我們可以用等化器對音頻訊號預先做處理

59
00:03:24.288 --> 00:03:26.080
補足喇叭不足之處

60
00:03:26.848 --> 00:03:30.432
那麼實務上要怎麼樣實現等化器的功能呢?

61
00:03:31.712 --> 00:03:37.600
我們可以用 SigmaDSP 系列的晶片來實現 PEQ等化器 的功能

62
00:03:37.856 --> 00:03:40.416
左邊是一個 DSP 的開發板

63
00:03:40.672 --> 00:03:45.280
中間是SigmaDSP系列的 ADAU1701晶片

64
00:03:45.536 --> 00:03:49.376
我們可以透過右邊的 USB to I2C converter

65
00:03:49.632 --> 00:03:51.424
來控制 DSP晶片

66
00:03:52.448 --> 00:03:56.800
首先我們透過電腦發出一個白噪音的音頻訊號

67
00:03:57.056 --> 00:03:59.104
傳給 SigmaDSP

68
00:03:59.616 --> 00:04:02.432
經過 PEQ 等化器的處理之後

69
00:04:02.688 --> 00:04:08.832
將訊號透過喇叭發出聲音來 再透過麥克風收音傳回給電腦

70
00:04:09.088 --> 00:04:11.904
做傅立葉轉換 並繪製頻譜圖

71
00:04:12.928 --> 00:04:18.303
那我們在 SigmaDSP 上面要如何實現PEQ等化器的功能呢?

72
00:04:18.815 --> 00:04:21.119
首先我們需要是 SigmaStudio

73
00:04:21.631 --> 00:04:25.471
這是一個設計訊號處理流程的 GUI界面

74
00:04:26.239 --> 00:04:32.383
左邊的樹狀目錄中提供了非常多的 DSP相關的功能 例如我們要設計

75
00:04:32.639 --> 00:04:34.175
一個 PEQ等化器

76
00:04:34.431 --> 00:04:37.503
只需要 第一個把 input 拉進來

77
00:04:38.527 --> 00:04:40.319
output 也拉進來

78
00:04:41.087 --> 00:04:43.391
中間再加一個 PEQ 的功能

79
00:04:43.647 --> 00:04:45.951
然後把線連起來

80
00:04:49.279 --> 00:04:51.327
再按一下 compile 跟 download

81
00:04:51.583 --> 00:04:52.607
這樣就完成了

82
00:04:53.119 --> 00:04:55.167
那把這個 PEQ 點開來

83
00:04:55.423 --> 00:04:58.495
就會出現參數的設定介面

84
00:04:59.007 --> 00:05:03.103
PEQ 的參數的改變會即時地控制 DSP的晶片

85
00:05:04.383 --> 00:05:09.247
我們可以用拖拉的方式來控制 PEQ 的中心頻率和增益

86
00:05:09.759 --> 00:05:12.575
來加強或衰減特定頻率範圍的能量

87
00:05:13.343 --> 00:05:16.159
像是這個喇叭的頻率響應曲線中

88
00:05:16.415 --> 00:05:18.719
右方有一個凹陷的地方

89
00:05:18.975 --> 00:05:21.279
我們就可以反相的加強它

90
00:05:21.535 --> 00:05:23.071
來把它填平

91
00:05:31.263 --> 00:05:34.335
我們可以同時透過多個 PEQ 等化器

92
00:05:34.591 --> 00:05:37.407
每一個 PEQ 各有各的中心頻率

93
00:05:37.663 --> 00:05:38.943
Q值與增益

94
00:05:39.199 --> 00:05:40.735
用來修正一個喇叭

95
00:05:40.991 --> 00:05:44.063
高高低低凹凸不平的頻率響應曲線

96
00:05:48.159 --> 00:05:51.487
那麼 SigmaDSP 的工作機制是什麼呢?

97
00:05:51.743 --> 00:05:54.559
我們以最簡單的 Mute 功能為例

98
00:05:54.815 --> 00:05:57.887
Mute 只是將數位訊號乘以 0 或 1

99
00:05:58.143 --> 00:06:03.007
當乘以 0 的時候就表示輸出也為 0 也就是靜音的意思

100
00:06:03.519 --> 00:06:06.591
讓我按下 compile 跟 download 這個按鍵的時候

101
00:06:07.103 --> 00:06:13.247
SigmaStudio 就會將程式跟參數兩份不同的資料

102
00:06:13.759 --> 00:06:18.367
傳給 DSP晶片 儲存於不同的記憶體區塊

103
00:06:21.183 --> 00:06:23.999
在DSP晶片的程式記憶體中

104
00:06:24.255 --> 00:06:28.095
Mute功能的程式碼片段看起來像是這樣子的

105
00:06:28.607 --> 00:06:31.423
它需要去存取一個在位址 0 的數值

106
00:06:31.679 --> 00:06:35.007
這個位址 0 指的是在參數記憶體裡面的位址

107
00:06:35.519 --> 00:06:37.823
所以我們只要想辦法去改動

108
00:06:38.079 --> 00:06:40.383
參數記憶體裡面位置 0 的數值

109
00:06:40.639 --> 00:06:43.711
就可以用程式去控制 Mute 的功能

110
00:06:44.735 --> 00:06:48.831
一個 SigmaStudio 的專案中除了 Mute 之外

111
00:06:49.343 --> 00:06:52.159
還會有各式各樣 DSP 的功能

112
00:06:52.671 --> 00:06:57.279
那我們怎麼知道每個功能的參數在記憶體中的位置呢?

113
00:06:59.327 --> 00:07:04.703
SigmaStudio 提供了 xml檔案 會匯總所有功能參數

114
00:07:05.215 --> 00:07:07.007
在記憶體中的位置

115
00:07:08.031 --> 00:07:14.175
那麼我們可以怎麼樣用 Python 來控制SigmaDSP晶片呢? 我們可以寫

116
00:07:14.431 --> 00:07:15.711
一些功能物件

117
00:07:16.223 --> 00:07:19.551
並支援對應的譬如說 set_mute 這樣的功能

118
00:07:19.807 --> 00:07:22.111
同時呢我們把對應的

119
00:07:22.623 --> 00:07:28.767
參數的位置 注射到這個物件裡面去 這樣這個物件以後在行使 set_mute 這樣的功

120
00:07:29.023 --> 00:07:30.047
能的時候就會

121
00:07:30.559 --> 00:07:36.703
把正確的參數位置一路往下傳遞 最後透過 I2C 的 bus

122
00:07:37.471 --> 00:07:39.775
把正確的資料寫到

123
00:07:40.031 --> 00:07:43.871
DSP晶片參數記憶體裡面正確的位置

124
00:07:45.151 --> 00:07:49.503
而在比較複雜的流程中會有比較多的功能方塊

125
00:07:49.759 --> 00:07:53.087
我們不但能用 Python 來控制它們

126
00:07:53.343 --> 00:07:55.903
而且可以組合各種控制的模式

127
00:07:56.159 --> 00:07:58.463
並寫成 Python 的 functions

128
00:07:58.975 --> 00:08:02.559
最終只需要一行程式 就可以做複雜的控制

129
00:08:03.583 --> 00:08:05.119
具體要怎麼做呢?

130
00:08:05.375 --> 00:08:08.703
首先我們必須要告訴 Factory 這個物件

131
00:08:08.959 --> 00:08:12.287
SigmaStudio專案的 xml檔案

132
00:08:12.543 --> 00:08:15.359
還有我們寫的功能物件類別定義檔

133
00:08:15.871 --> 00:08:16.639
所在的位置

134
00:08:17.919 --> 00:08:20.479
接下來我們會產生一個 IC 物件

135
00:08:20.735 --> 00:08:23.039
它就代表了 SigmaStudio

136
00:08:23.295 --> 00:08:25.855
專案 xml 檔案的內容

137
00:08:26.111 --> 00:08:28.159
它知道有哪些功能物件

138
00:08:28.415 --> 00:08:32.255
以及相對應的 在參數記憶體中的位置

139
00:08:33.279 --> 00:08:38.143
接下來 Factory 會根據 IC 也就是 xml檔案的內容

140
00:08:38.399 --> 00:08:40.703
為各個功能方塊建立物件

141
00:08:40.959 --> 00:08:43.775
並且把對應的參數記憶體位置

142
00:08:44.287 --> 00:08:46.079
注入到功能物建中

143
00:08:47.359 --> 00:08:51.967
這樣我們就可以透過功能物件 來控制 DSP 晶片的行為

144
00:08:52.223 --> 00:08:55.551
另外我們還可以把不同功能物件的 functions

145
00:08:55.807 --> 00:08:57.855
組合成複雜的控製程序

146
00:08:58.879 --> 00:08:59.647
而且

147
00:08:59.903 --> 00:09:01.951
我們只要再多花一點心力

148
00:09:02.207 --> 00:09:06.047
在中間加上一組 TCP/IP 的 client 跟 server

149
00:09:06.303 --> 00:09:08.351
就可以透過無線網路

150
00:09:08.607 --> 00:09:10.911
控制遠端的 DSP 模組

151
00:09:11.679 --> 00:09:17.567
透過 Python 跟無線網路來控制 DSP 模組有什麼好處呢?

152
00:09:18.335 --> 00:09:20.639
第一個 透過無線網路來控制

153
00:09:20.895 --> 00:09:22.431
只要網路能連得上

154
00:09:22.687 --> 00:09:24.223
我們都可以控制它們

155
00:09:24.735 --> 00:09:25.759
所以在

156
00:09:26.015 --> 00:09:28.575
佈署與維護上是非常方便的

157
00:09:29.343 --> 00:09:35.487
第二個 因為我們現在可以用 Python 來控制 DSP 模組 所以我們可以把很多

158
00:09:35.743 --> 00:09:36.767
複雜的功能

159
00:09:37.023 --> 00:09:38.303
通通濃縮成

160
00:09:38.559 --> 00:09:40.095
一個 Python 的 function

161
00:09:40.607 --> 00:09:44.191
我們要控制這些功能 只需要一行指令就可以了

162
00:09:44.447 --> 00:09:48.543
而且透過無線網路我們可以同時控制很多個

163
00:09:48.799 --> 00:09:50.335
DSP 的設備

164
00:09:51.359 --> 00:09:52.127
第三個

165
00:09:52.383 --> 00:09:55.967
以往的 DSP 設備裡面都會有 微控制器

166
00:09:56.223 --> 00:09:57.503
來做功能的控制 與

167
00:09:57.759 --> 00:09:58.783
參數的計算

168
00:09:59.295 --> 00:10:05.439
那麼現在我們可以從遠端用 Python 程式做參數的計算與功能控制

169
00:10:05.951 --> 00:10:08.511
那麼 DSP 設備裡面的結構

170
00:10:08.767 --> 00:10:10.559
就可以大幅的簡化

171
00:10:11.839 --> 00:10:12.607
第四個

172
00:10:13.375 --> 00:10:17.727
以往 DSP 設備上面都會有很多按鈕與旋鈕

173
00:10:18.239 --> 00:10:22.079
那麼我們可以透過網路用軟體來控制之後

174
00:10:22.335 --> 00:10:24.895
這些控制的按鈕與旋鈕

175
00:10:25.151 --> 00:10:26.687
也許就不再需要了

176
00:10:28.479 --> 00:10:29.247
最後

177
00:10:29.503 --> 00:10:31.295
不論是什麼樣的資源

178
00:10:31.551 --> 00:10:34.367
必須要能很容易的存取使用

179
00:10:34.879 --> 00:10:37.439
所以 可以透過程式碼來控制

180
00:10:37.695 --> 00:10:41.023
可以透過無線網路來存取 是必須的

181
00:10:41.535 --> 00:10:43.583
這樣才有後續發展的可能

182
00:10:44.863 --> 00:10:47.423
這是我用來做實驗的組合模組

183
00:10:47.679 --> 00:10:51.263
左方的是 ADAU1701 的晶片

184
00:10:51.775 --> 00:10:54.847
中間的是 USB to I2C 的 converter

185
00:10:55.359 --> 00:10:57.407
右邊的是 TCP/IP 的 server

186
00:10:57.919 --> 00:11:00.991
下方的端口是 input，上方的是 output

187
00:11:02.015 --> 00:11:07.135
有了這樣的工具之後 我們就可以做很多應用 譬如說 AutoEQ

188
00:11:07.647 --> 00:11:10.207
AutoEQ 就是透過程式的方法

189
00:11:10.463 --> 00:11:13.023
將喇叭的頻率響應做最佳化

190
00:11:14.559 --> 00:11:18.143
我們藉由行動電源來為組合模組供電

191
00:11:18.911 --> 00:11:22.495
而輸出的訊號接到一個小型的擴大機

192
00:11:23.007 --> 00:11:25.823
然後推動兩個喇叭來發出聲音

193
00:11:27.103 --> 00:11:28.639
整個流程是這樣子的

194
00:11:29.151 --> 00:11:30.687
首先透過電腦

195
00:11:31.199 --> 00:11:34.783
命令 DSP 模組產生白噪音的訊號

196
00:11:35.039 --> 00:11:37.087
透過喇叭發出聲音之後

197
00:11:37.343 --> 00:11:43.487
再透過麥克風收回到電腦裡面做分析 並計算所需要的 PEQ 參數

198
00:11:43.743 --> 00:11:47.583
再透過無線網路佈署到 DSP 模組上面去

199
00:11:48.863 --> 00:11:55.007
由電腦收音分析 然後透過無線網路 把計算好的參數推送給遠端

200
00:11:55.263 --> 00:11:56.543
的 DSP 模組

201
00:11:56.799 --> 00:11:58.335
就可以修正音色

202
00:12:00.383 --> 00:12:06.527
頻率響應原本需要透過人工慢慢調整 現在完全可以在遠端透過

203
00:12:06.783 --> 00:12:07.807
程式自動修正

204
00:12:08.319 --> 00:12:14.463
首先我們要先做收音並分析頻譜 計算出所需要的 PEQ 參數

205
00:12:14.719 --> 00:12:18.559
然後透過網路佈署到遠端的 DSP 模組

206
00:12:18.815 --> 00:12:21.375
這樣就可以修正喇叭的頻率響應

207
00:12:26.239 --> 00:12:28.287
這是 AutoEQ 之前

208
00:12:28.799 --> 00:12:29.567
跟之後

209
00:12:29.823 --> 00:12:31.359
的頻率響應對比

210
00:12:31.615 --> 00:12:32.895
具有一定的效果

211
00:12:35.199 --> 00:12:38.783
在這過程中為了對 PEQ 參數作最佳化

212
00:12:39.295 --> 00:12:42.879
所用到的是 Jaakko Pasanen 所寫的一個 Python 模組

213
00:12:43.903 --> 00:12:48.255
它的原理是這樣子的 根據頻率響應中的波峰與波谷

214
00:12:48.511 --> 00:12:51.839
設定每一個 PEQ 等化器的中心頻率

215
00:12:52.095 --> 00:12:53.631
然後根據預估

216
00:12:53.887 --> 00:12:57.471
響應曲線 與 目標響應曲線 的 最小均方差

217
00:12:57.727 --> 00:12:58.751
用梯度下降

218
00:12:59.007 --> 00:13:01.567
對每一個 PEQ 等化器的 Q值

219
00:13:01.823 --> 00:13:02.591
跟 增益

220
00:13:02.847 --> 00:13:03.615
做最佳化

221
00:13:04.639 --> 00:13:08.735
以二聲道的音響來說 為了要獲得最佳的音效

222
00:13:08.991 --> 00:13:11.039
除了頻率響應的調整之外

223
00:13:11.295 --> 00:13:13.855
我們還需要調整左右喇叭的延遲

224
00:13:16.159 --> 00:13:17.951
一個訊號一分為二

225
00:13:18.463 --> 00:13:20.767
由左右兩個喇叭發出聲音

226
00:13:21.023 --> 00:13:23.327
但是因為與聽者的距離不同

227
00:13:23.583 --> 00:13:28.447
如果希望左右喇叭所發出的聲音能同時抵達聽者的位置

228
00:13:28.959 --> 00:13:31.519
則必須要將一方喇叭的訊號

229
00:13:31.775 --> 00:13:33.055
做一些延遲

230
00:13:36.895 --> 00:13:39.967
像是圖中紅色的訊號領先綠色的

231
00:13:40.479 --> 00:13:44.319
那我們怎麼知道 需要將紅色訊號做多少延遲呢?

232
00:13:45.087 --> 00:13:48.159
我們可以將紅色的訊號故意做反向

233
00:13:49.695 --> 00:13:51.487
當延遲最佳化的時候

234
00:13:51.999 --> 00:13:54.815
兩個訊號會有最大程度的抵銷

235
00:13:55.327 --> 00:13:57.375
合成的總音壓就會最小

236
00:13:57.631 --> 00:14:00.703
所以我們只要微調其中一方的 delay

237
00:14:00.959 --> 00:14:04.799
直到合成的總音壓最小 就表示 delay 已經最佳化了

238
00:14:13.247 --> 00:14:16.831
左邊是近距離對一組藍牙喇叭所描繪的

239
00:14:17.087 --> 00:14:19.391
delay 與合成聲壓關係圖

240
00:14:20.415 --> 00:14:24.255
右邊是對一組兩公尺外的書架喇叭的測量結果

241
00:14:25.535 --> 00:14:29.119
也正因為左右喇叭距離聽者的距離不同

242
00:14:29.631 --> 00:14:31.679
除了需要調整 delay 之外

243
00:14:32.191 --> 00:14:33.727
音量也需要調整

244
00:14:34.751 --> 00:14:36.543
這邊用的機制就很簡單

245
00:14:37.055 --> 00:14:39.615
讓各個喇叭輪流發出白噪音

246
00:14:40.127 --> 00:14:43.967
量測音壓之後 調整各個喇叭的音量增益

247
00:14:44.223 --> 00:14:48.063
最終讓聽者聽到各個喇叭的音量相同就可以了

248
00:14:55.743 --> 00:14:59.327
我們除了可以將喇叭的頻率響應曲線拉平之外

249
00:14:59.583 --> 00:15:02.911
其實我們可以將它雕塑成很多其他的形狀

250
00:15:03.167 --> 00:15:04.447
例如這個曲線

251
00:15:06.751 --> 00:15:08.031
這是 Harman Curve

252
00:15:08.287 --> 00:15:10.847
是由 Harman International 這家公司

253
00:15:11.103 --> 00:15:12.895
經過調查與統計出來的

254
00:15:13.407 --> 00:15:16.223
代表人們對耳機頻率響應的偏好

255
00:15:17.247 --> 00:15:20.575
所以市面上很多耳機在設計的時候

256
00:15:20.831 --> 00:15:24.927
都會試著 讓頻率響應曲線盡量接近 Harman Curve

257
00:15:25.695 --> 00:15:28.511
我們同樣可以藉由 AutoEQ 的技術

258
00:15:28.767 --> 00:15:30.815
將一副耳機的頻率響應

259
00:15:31.071 --> 00:15:32.863
調整成哈曼曲線

260
00:15:33.887 --> 00:15:38.751
首先 我們需要先取得耳機原本的頻率響應曲線

261
00:15:39.263 --> 00:15:41.311
我們可以用這樣的一個設備

262
00:15:41.823 --> 00:15:45.407
來量測耳機的頻率響應 然後計算出

263
00:15:45.663 --> 00:15:47.455
所需要的 PEQ 參數

264
00:15:48.479 --> 00:15:52.319
或者 我們可以利用網路上現有的 database

265
00:15:53.087 --> 00:15:55.903
他們已經針對市面上很多耳機

266
00:15:56.159 --> 00:15:59.487
做了逼近 Harman 曲線 的 AutoEQ

267
00:15:59.743 --> 00:16:02.815
並列出所需要的 PEQ 參數

268
00:16:04.351 --> 00:16:06.143
有了這樣的參數之後

269
00:16:06.399 --> 00:16:09.215
我們就可以透過硬體的 DSP

270
00:16:09.471 --> 00:16:11.519
譬如說 SigmaDSP 的晶片

271
00:16:12.031 --> 00:16:14.079
來做頻率響應的調整

272
00:16:14.591 --> 00:16:16.127
或者我們可以把參數

273
00:16:16.383 --> 00:16:18.943
丟到電腦上的 軟體DSP

274
00:16:19.199 --> 00:16:21.759
這樣就可以對頻率響應作修正

275
00:16:22.783 --> 00:16:25.343
我們還可以將耳機的頻率響應

276
00:16:25.599 --> 00:16:27.135
改成其他的曲線

277
00:16:27.647 --> 00:16:30.463
例如 其他耳機的頻率響應曲線

278
00:16:31.487 --> 00:16:34.303
我們只要知道兩者的頻率響應

279
00:16:34.559 --> 00:16:36.863
就可以透過 AutoEQ 的方式

280
00:16:37.119 --> 00:16:42.751
產出所需要的 PEQ 參數 讓我們的耳機去模仿另一款耳機

281
00:16:45.055 --> 00:16:47.615
這邊有一個小工具可以計算

282
00:16:47.871 --> 00:16:51.199
做頻率響應轉換 所需要的 PEQ 參數

283
00:16:53.247 --> 00:16:57.087
我是 Wei Lin，以上就是今天要跟各位分享的內容

284
00:16:57.599 --> 00:16:59.135
希望你會覺得很有趣
